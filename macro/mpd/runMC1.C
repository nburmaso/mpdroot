#if !defined(__CINT__) && !defined(__CLING__)
#include "TString.h"
#include "TStopwatch.h"
#include "TROOT.h"
#include "TSystem.h"
#include "TMath.h"
#include "TDatabasePDG.h"

#include "FairRunSim.h"
#include "FairRuntimeDb.h"
#include "FairParRootFileIo.h"
#include "FairTrajFilter.h"
#include "FairUrqmdGenerator.h"
#include "FairPrimaryGenerator.h"
#include "MpdLAQGSMGenerator.h"
#include "FairCave.h"
#include "FairPipe.h"
#include "FairMagnet.h"

#include "TpcDetector.h"
#include "MpdEmc.h"
#include "MpdTof.h"
#include "MpdZdc.h"
#include "MpdFfd.h"
#include "MpdMultiField.h"
#include "MpdMultiFieldPar.h"
#include "MpdConstField.h"
#include "MpdFieldMap.h"
#include "MpdGetNumEvents.h"

#include <iostream>
using namespace std;
#endif

R__ADD_INCLUDE_PATH($VMCWORKDIR)
#include "mpdloadlibs.C"
//#include "macro/mpd/geometry_stage1.C"
#include "geometry_v1.C"
//#include "macro/mpd/geometry_v2.C"

#define BOX  // Choose generator: URQMD VHLLE FLUID PART ION BOX HSD LAQGSM HADGEN
#define GEANT3  // Choose: GEANT3 GEANT4

// inFile - input file with generator data, default: auau.09gev.mbias.98k.ftn14
// nStartEvent - for compatibility, any number
// nEvents - number of events to transport, default: 1
// outFile - output file with MC data, default: evetest.root
// flag_store_FairRadLenPoint
// FieldSwitcher: 0 - corresponds to the ConstantField (0, 0, 5) kG (It is used by default); 1 - corresponds to the FieldMap ($VMCWORKDIR/input/B-field_v2.dat)
void runMC1(TString inFile = "/home/demezhan/proograms/DCQGSM/Au_Au_mb/AuAuss5mb1_mer.r12.gz"
                            /*"/home/demezhan/proograms/urqmd-3.4/test.f14"*/, 
            TString outFile = /*"/home/demezhan/proograms/DCQGSM/Bmd_QGSM_AuAu_mb/ZDC_LAQGSM_AuAu_5GeV.root",*/
                                "evetest.root",
            Int_t nStartEvent = 0, Int_t nEvents = 2,
            Bool_t flag_store_FairRadLenPoint = kFALSE, Int_t FieldSwitcher = 0)
{
    TStopwatch timer;
    timer.Start();
    gDebug = 0;

    FairRunSim* fRun = new FairRunSim();
    // Choose the Geant Navigation System
#ifdef GEANT3
    fRun->SetName("TGeant3");
#else
    fRun->SetName("TGeant4");
#endif
    //geometry_stage1(fRun);
    geometry_v1(fRun); // load mpd geometry
    //geometry_v2(fRun); // load mpd geometry

    // Use extended MC Event header instead of the default one.
    //MpdMCEventHeader* mcHeader = new MpdMCEventHeader();
    //fRun->SetMCEventHeader(mcHeader);

    // Create and Set Event Generator
    FairPrimaryGenerator* primGen = new FairPrimaryGenerator();
    fRun->SetGenerator(primGen);

    // smearing of beam interaction point
    primGen->SetBeam(0.0,0.0,0.1,0.1);
    primGen->SetTarget(0.0,24.0);
    primGen->SmearGausVertexZ(kTRUE);
    primGen->SmearVertexXY(kTRUE);

    // Use user defined decays https://fairroot.gsi.de/?q=node/57
    fRun->SetUserDecay(kTRUE);
    
#ifdef MCDST // McDst generator
    if (!CheckFileExist(inFile)) return;

    MpdMcDstGenerator* mcDstGen = new MpdMcDstGenerator(inFile);
    primGen->AddGenerator(mcDstGen);

#else    
#ifdef URQMD // <---- Urqmd  Generator
    if (!CheckFileExist(inFile)) return;

    MpdUrqmdGenerator* urqmdGen = new MpdUrqmdGenerator(inFile);
    // Event plane angle (in degrees) will be generated by uniform distribution from min to max
    Float_t min = 0.0, max = 30.0;
    urqmdGen->SetEventPlane(min * TMath::DegToRad(), max * TMath::DegToRad());
    primGen->AddGenerator(urqmdGen);
    if (nStartEvent > 0) urqmdGen->SkipEvents(nStartEvent);

    // if nEvents is equal 0 then all events (start with nStartEvent) of the given file should be processed
    if (nEvents == 0)
        nEvents = MpdGetNumEvents::GetNumURQMDEvents(inFile.Data()) - nStartEvent;

#else
#ifdef VHLLE
    if (!CheckFileExist(inFile)) return;

    MpdVHLLEGenerator* vhlleGen = new MpdVHLLEGenerator(inFile, kTRUE); // kTRUE corresponds to hydro + cascade, kFALSE -- hydro only
    vhlleGen->SkipEvents(0);
    primGen->AddGenerator(vhlleGen);

#else 
#ifdef FLUID
    if (!CheckFileExist(inFile)) return;

    Mpd3fdGenerator* fluidGen = new Mpd3fdGenerator(inFile);
    if (nStartEvent > 0) fluidGen->SkipEvents(nStartEvent);
    //fluidGen->SetPsiRP(0.); // set fixed Reaction Plane angle [rad] instead of random
    //fluidGen->SetProtonNumberCorrection(79./197.); // Z/A Au for Theseus 2018-03-17-bc2a06d
    primGen->AddGenerator(fluidGen);

#else
#ifdef PART // <---- Particle Generator
    FairParticleGenerator* partGen =
            new FairParticleGenerator(211, 10, 1, 0, 3, 1, 0, 0);
    primGen->AddGenerator(partGen);

#else
#ifdef ION // <---- Ion Generator
    FairIonGenerator *fIongen =
            new FairIonGenerator(79, 197, 79, 1, 0., 0., 25, 0., 0., -1.);
    primGen->AddGenerator(fIongen);

#else
#ifdef BOX // <---- Box Generator
    //gRandom->SetSeed(0);
          // Box Generator

  FairBoxGenerator* boxGen1 = new FairBoxGenerator(13, 1000); // 13 = muon; 1 = multipl.
  boxGen1->SetPRange(0.25,2.5); // GeV/c //setPRange vs setPtRange
  boxGen1->SetPhiRange(0, 360); // Azimuth angle range [degree]
  //boxGen->SetThetaRange(0, 180); // Polar angle in lab system range [degree]
  Float_t theta0 = TMath::ATan2(10.,199.);
  theta0 = TMath::RadToDeg()*theta0;
  Float_t theta1 = TMath::RadToDeg()*TMath::ATan2(50.,199.);
//    cout << "DDDDDD " << theta0 << " " << theta1;
  boxGen1->SetThetaRange(theta0, theta1); // Polar angle in lab system range [degree]
  boxGen1->SetXYZ(0., 0., 0.); // mm o cm ??

  FairBoxGenerator* boxGen2 = new FairBoxGenerator(13, 1000); // 13 = muon; 1 = multipl.
  boxGen2->SetPRange(0.25,2.5); // GeV/c //setPRange vs setPtRange
  boxGen2->SetPhiRange(0, 360); // Azimuth angle range [degree]
  //boxGen->SetThetaRange(0, 180); // Polar angle in lab system range [degree]
  theta0 = TMath::ATan2(10.,-199.);
  theta0 = TMath::RadToDeg()*theta0;
  theta1 = TMath::RadToDeg()*TMath::ATan2(50.,-199.);
//    cout << "DDDDDD " << theta0 << " " << theta1;
  boxGen2->SetThetaRange(theta0, theta1); // Polar angle in lab system range [degree]
  boxGen2->SetXYZ(0., 0., 0.); // mm o cm ??

  primGen->AddGenerator(boxGen1);
  primGen->AddGenerator(boxGen2); 

/*      // Box Generator
  FairBoxGenerator* boxGen = new
    FairBoxGenerator(2212, 100); // 13 = muon; 1 = multipl.
    boxGen->SetPtRange(.2,2.5); // GeV/c //setPRange vs setPtRange
    boxGen->SetPhiRange(0, 360); // Azimuth angle range [degree]
    Float_t theta0 = TMath::ATan2(10.,199.);
    theta0 = TMath::RadToDeg()*theta0;
    Float_t theta1 = TMath::RadToDeg()*TMath::ATan2(50.,199.);
//    cout << "DDDDDD " << theta0 << " " << theta1;
    boxGen->SetThetaRange(theta0, theta1); // Polar angle in lab system range [degree]
    boxGen->SetXYZ(0., 0., 0.); // mm o cm ??
   
     primGen->AddGenerator(boxGen);
*/
/*
    const Double_t r = 127;
    const Double_t P1 = 10;
    const Double_t phi1 = 0;
    const Double_t phi2 = 90;
    const Double_t theta1 = 147;
    const Double_t theta2 = 11;
    const Double_t z = 40;
    const Double_t zz = 50;

    Double_t phi1_rad = TMath::DegToRad()*phi1;
    Double_t phi2_rad = TMath::DegToRad()*phi2;
    Double_t theta1_rad = TMath::DegToRad()*theta1;
    Double_t theta2_rad = TMath::DegToRad()*theta2;
    Double_t x;
    Double_t y;
    Double_t Px;
    Double_t Py;  
    
    for (Int_t k = 0; k < 4; k++)
    {
    for (Int_t i = 0; i < 4; i++)
    {
    for(Int_t j=0; j< 7; j++)
      {
        x = r*TMath::Cos(phi1_rad+i*phi2_rad);
        y = r*TMath::Sin(phi1_rad+i*phi2_rad);
        Px = P1*TMath::Cos(theta1_rad+j*theta2_rad+i*phi2_rad);
        Py = P1*TMath::Sin(theta1_rad+j*theta2_rad+i*phi2_rad);
        FairBoxGenerator* boxGen = new FairBoxGenerator (, 1);
        //   FairParticleGenerator* partGen1 = new FairParticleGenerator (211, 1, Px, Py, 0, x, y, 0);
        boxGen->SetPhiRange((theta1+j*theta2+i*phi2), (theta1+j*theta2+i*phi2)); 
        boxGen->SetThetaRange(147, 11);
        boxGen->SetEkinRange(25.0, 20.0);//GeV
        boxGen->SetXYZ(x, y, (zz+k*z));
        primGen->AddGenerator(boxGen); 
        
      }
    }
  }
  for (Int_t k = 0; k < 4; k++)
  {
    for (Int_t i = 0; i < 4; i++)
    {
    for(Int_t j=0; j< 7; j++)
      {
        x = r*TMath::Cos(phi1_rad+i*phi2_rad);
        y = r*TMath::Sin(phi1_rad+i*phi2_rad);
        Px = P1*TMath::Cos(theta1_rad+j*theta2_rad+i*phi2_rad);
        Py = P1*TMath::Sin(theta1_rad+j*theta2_rad+i*phi2_rad);
        FairBoxGenerator* boxGen = new FairBoxGenerator (2212, 1);
        //   FairParticleGenerator* partGen1 = new FairParticleGenerator (211, 1, Px, Py, 0, x, y, 0);
        boxGen->SetPhiRange((theta1+j*theta2+i*phi2), (theta1+j*theta2+i*phi2)); 
        boxGen->SetThetaRange(147, 11);
        boxGen->SetEkinRange(25.0, 20.0);//GeV
        boxGen->SetXYZ(x, y, -(zz+k*z));
        primGen->AddGenerator(boxGen); 
          
      }
    }
  }
*/
#else
#ifdef HSD // <---- HSD/PHSD Generator
    if (!CheckFileExist(inFile)) return;

    MpdPHSDGenerator *hsdGen = new MpdPHSDGenerator(inFile.Data());
    //hsdGen->SetPsiRP(0.); // set fixed Reaction Plane angle [rad] instead of random
    primGen->AddGenerator(hsdGen);
    if (nStartEvent > 0) hsdGen->SkipEvents(nStartEvent);

    // if nEvents is equal 0 then all events (start with nStartEvent) of the given file should be processed
    if (nEvents == 0)
        nEvents = MpdGetNumEvents::GetNumPHSDEvents(inFile.Data()) - nStartEvent;

#else
#ifdef LAQGSM // <---- LAQGSM Generator
    if (!CheckFileExist(inFile)) return;

    MpdLAQGSMGenerator* guGen = new MpdLAQGSMGenerator(inFile.Data(), kTRUE, 0, 1+nStartEvent+nEvents);
    // kTRUE - for NICA/MPD, 1+nStartEvent+nEvents - search ions in selected part of file.
    primGen->AddGenerator(guGen);
    if (nStartEvent > 0) guGen->SkipEvents(nStartEvent);

    // if nEvents is equal 0 then all events (start with nStartEvent) of the given file should be processed
    if (nEvents == 0)
        nEvents = MpdGetNumEvents::GetNumQGSMEvents(inFile.Data()) - nStartEvent;

#else
#ifdef HADGEN
    THadgen* hadGen = new THadgen();
    hadGen->SetRandomSeed(clock() + time(0));
    hadGen->SetParticleFromPdgCode(0, 196.9665, 79);
    hadGen->SetEnergy(6.5E3);
    MpdGeneralGenerator* generalHad = new MpdGeneralGenerator(hadGen);
    primGen->AddGenerator(generalHad);

#endif
#endif
#endif
#endif
#endif
#endif
#endif
#endif
#endif 
#endif 

    fRun->SetOutputFile(outFile.Data());

    // Magnetic Field Map - for proper use in the analysis MultiField is necessary here
    MpdMultiField* fField = new MpdMultiField();

    if (FieldSwitcher == 0) {
        MpdConstField* fMagField = new MpdConstField();
        fMagField->SetField(0., 0., 5.); // values are in kG:  1T = 10kG
        fMagField->SetFieldRegion(-230, 230, -230, 230, -375, 375);
        fField->AddField(fMagField);
        fRun->SetField(fField);
        cout << "FIELD at (0., 0., 0.) = (" <<
                fMagField->GetBx(0., 0., 0.) << "; " << fMagField->GetBy(0., 0., 0.) << "; " << fMagField->GetBz(0., 0., 0.) << ")" << endl;
    }
    else if (FieldSwitcher == 1) {
        MpdFieldMap* fMagField = new MpdFieldMap("B-field_v2", "A");
        fMagField->Init();
        fField->AddField(fMagField);
        fRun->SetField(fField);
        cout << "FIELD at (0., 0., 0.) = (" <<
                fMagField->GetBx(0., 0., 0.) << "; " << fMagField->GetBy(0., 0., 0.) << "; " << fMagField->GetBz(0., 0., 0.) << ")" << endl;
    }

    fRun->SetStoreTraj(kTRUE);
    fRun->SetRadLenRegister(flag_store_FairRadLenPoint); // radiation length manager

    //  MpdTpcDigitizerTask* tpcDigitizer = new MpdTpcDigitizerTask();
    //  tpcDigitizer->SetOnlyPrimary(kTRUE); /// Digitize only primary track
    //  tpcDigitizer->SetMakeQA(kTRUE);  /// SetMakeQA(kTRUE) prepares Quality Assurance Histograms  
    //  tpcDigitizer->SetDiffuse(kFALSE);
    //  tpcDigitizer->SetDebug(kFALSE);
    //  tpcDigitizer->SetDistort(kFALSE);
    //  tpcDigitizer->SetResponse(kFALSE);
    //  tpcDigitizer->SetDistribute(kFALSE);
    //  fRun->AddTask(tpcDigitizer);

    fRun->Init();

    // -Trajectories Visualization (TGeoManager Only)
    // Set cuts for storing the trajectories
    FairTrajFilter* trajFilter = FairTrajFilter::Instance();
    trajFilter->SetStepSizeCut(0.01); // 1 cm
    //  trajFilter->SetVertexCut(-2000., -2000., 4., 2000., 2000., 100.);
    trajFilter->SetMomentumCutP(.50); // p_lab > 500 MeV
    //  trajFilter->SetEnergyCut(.2, 3.02); // 0 < Etot < 1.04 GeV

    trajFilter->SetStorePrimaries(kTRUE);
    trajFilter->SetStoreSecondaries(kFALSE);

    // Fill the Parameter containers for this run
    FairRuntimeDb* rtdb = fRun->GetRuntimeDb();

    Bool_t kParameterMerged = kTRUE;
    FairParRootFileIo* output = new FairParRootFileIo(kParameterMerged);
    //AZ output->open(parFile.Data());
    output->open(gFile);
    rtdb->setOutput(output);

    MpdMultiFieldPar* Par = (MpdMultiFieldPar*) rtdb->getContainer("MpdMultiFieldPar");
    if (fField)
        Par->SetParameters(fField);
    Par->setInputVersion(fRun->GetRunId(), 1);
    Par->setChanged();
    // Par->printParams();

    rtdb->saveOutput();
    rtdb->print();

    // Transport nEvents
    fRun->Run(nEvents);

#ifdef LAQGSM
    TString Pdg_table_name = TString::Format("%s%s%c%s", gSystem->BaseName(inFile.Data()), ".g", (fRun->GetName())[6], ".pdg_table.dat");
    (TDatabasePDG::Instance())->WritePDGTable(Pdg_table_name.Data());
#endif

    timer.Stop();
    Double_t rtime = timer.RealTime(), ctime = timer.CpuTime();
    printf("RealTime=%f seconds, CpuTime=%f seconds\n", rtime, ctime);
    cout << "Macro finished successfully." << endl;     // marker of successful execution for CDASH
}
